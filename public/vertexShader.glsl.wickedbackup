#define pi 3.141592653589793238462643383279
varying vec2 vUv;
uniform vec4 rotation;
uniform float radius;
uniform float minTheta;
uniform float maxTheta;
uniform float scale;

vec3 rotateVector( vec4 quat, vec3 vec ){
    return vec + 2.0 * cross( cross( vec, quat.xyz ) + quat.w * vec, quat.xyz );
}

vec4 createQuaternionFromAxisAngle( vec3 axis, float angle ) { 
    
    vec4 quat;

    float halfAngle = angle / 2.0;
    float s = sin( halfAngle );
    
    quat.x = axis.x * s;
    quat.y = axis.y * s;
    quat.z = axis.z * s;
    quat.w = cos( halfAngle );
    
    return quat;

}

void main() {
 
	vUv = uv;

	vec3 newPosition = position;

	float scal = 1.0 / pow(2.0,scale); //scale = 1 then  .5
	float nscal = 1.0 / pow(2.0,scale+1.0); //scale = 2 then  .25

//vec2 abspos = vec2((position.x + deformableOffset.x) / subdivisions, (position.z + deformableOffset.y) / subdivisions);
//deformableOffset.x and .y represent the (x,y) coordinates for that particular instance of the plane, remember it's a grid of 4x4 tiles

	float tphi = (newPosition.x - .5) * scal * pi;
	float ttheta = (newPosition.y - .5) * pi * scal + pi / 2.0;

	newPosition = vec3(-1.0*sin(tphi) * sin(ttheta), cos(ttheta), cos(tphi) * sin(ttheta));

	newPosition *= radius;

	

	gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
}


/*
for x = .5 y = 1
	tphi = 0
	ttheta a
	*/
